This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

Additional Info:
----------------

================================================================
Directory Structure
================================================================
lib/
  config/
    level-definitions.config.ts
    level-thresholds.ts
    xp-values.config.ts
  progression/
    commands/
      command-factory.ts
      process-game-action.command.ts
      update-progression.command.ts
    core/
      progression-events.model.ts
      progression-state.model.ts
      service-registry.ts
      xp-calculation.model.ts
    events/
      event-processor.service.ts
      event-publisher.service.ts
    handlers/
      actions/
        code-push.handler.ts
        code-review.handler.ts
        pull-request.handler.ts
      action-handler.base.ts
      action-handler.factory.ts
    repositories/
      activity.repository.ts
      game-action.repository.ts
      progression.repository.ts
    services/
      activity-recorder.service.ts
      milestone-reward.service.ts
      progression.service.ts
      xp-calculator.service.ts
    utils/
      level.utils.ts
  rewards/
    services/
      badge.service.ts
      level.service.ts
      reward.service.ts
  utils/
    time-periods.utils.ts
index.ts

================================================================
Files
================================================================

================
File: lib/config/level-definitions.config.ts
================
import { LevelRequirementItem } from '@codeheroes/types';

/**
 * Defines the configuration for each level, including XP requirements and rewards
 * (This was previously named LEVEL_CONFIGURATION)
 */
export interface LevelDefinition {
  level: number;
  xpRequired: number;
  requirements?: LevelRequirementItem[];
  rewards?: {
    title?: string;
    badges?: string[];
    unlocks?: string[];
  };
}

export const LEVEL_DEFINITIONS: LevelDefinition[] = [
  {
    level: 1,
    xpRequired: 0,
    rewards: {
      title: 'Code Novice',
      badges: ['novice_coder'],
    },
  },
  {
    level: 2,
    xpRequired: 1000,
    rewards: {
      title: 'Code Explorer',
      badges: ['code_explorer'],
    },
  },
  {
    level: 3,
    xpRequired: 2500,
    rewards: {
      title: 'Code Adept',
      badges: ['code_adept'],
    },
  },
  {
    level: 4,
    xpRequired: 5000,
    rewards: {
      title: 'Code Enthusiast',
      badges: ['code_enthusiast'],
    },
  },
  {
    level: 5,
    xpRequired: 10000,
    rewards: {
      title: 'Code Hero',
      badges: ['code_hero'],
    },
  },
  {
    level: 6,
    xpRequired: 20000,
    rewards: {
      title: 'Code Veteran',
      badges: ['code_veteran'],
    },
  },
  {
    level: 7,
    xpRequired: 35000,
    rewards: {
      title: 'Code Master',
      badges: ['code_master'],
    },
  },
  {
    level: 8,
    xpRequired: 55000,
    rewards: {
      title: 'Code Legend',
      badges: ['code_legend'],
    },
  },
  {
    level: 9,
    xpRequired: 80000,
    rewards: {
      title: 'Code Champion',
      badges: ['code_champion'],
    },
  },
  {
    level: 10,
    xpRequired: 110000,
    rewards: {
      title: 'Code Oracle',
      badges: ['code_oracle'],
    },
  },
];

================
File: lib/config/level-thresholds.ts
================
import { LEVEL_DEFINITIONS } from './level-definitions.config';

export function calculateXpForLevel(level: number): number {
  const config = LEVEL_DEFINITIONS.find((c) => c.level === level);
  return config?.xpRequired ?? 0;
}

export function getLevelFromXp(totalXp: number): number {
  const level = LEVEL_DEFINITIONS.findIndex(
    (config, index, array) =>
      totalXp >= config.xpRequired && (index === array.length - 1 || totalXp < array[index + 1].xpRequired),
  );
  return level === -1 ? 1 : LEVEL_DEFINITIONS[level].level;
}

export function getXpProgress(totalXp: number): {
  currentLevel: number;
  currentLevelXp: number;
  xpToNextLevel: number;
} {
  const currentLevelConfig = LEVEL_DEFINITIONS.find(
    (config, index, array) =>
      totalXp >= config.xpRequired && (index === array.length - 1 || totalXp < array[index + 1].xpRequired),
  );

  if (!currentLevelConfig) {
    return {
      currentLevel: 1,
      currentLevelXp: 0,
      xpToNextLevel: LEVEL_DEFINITIONS[1].xpRequired,
    };
  }

  const nextLevelConfig = LEVEL_DEFINITIONS.find((config) => config.level === currentLevelConfig.level + 1);

  return {
    currentLevel: currentLevelConfig.level,
    currentLevelXp: totalXp - currentLevelConfig.xpRequired,
    xpToNextLevel: nextLevelConfig ? nextLevelConfig.xpRequired - totalXp : 0,
  };
}

export function getLevelRequirements(level: number) {
  return LEVEL_DEFINITIONS.find((config) => config.level === level);
}

export function getNextLevelRequirements(level: number) {
  return LEVEL_DEFINITIONS.find((config) => config.level === level + 1);
}

================
File: lib/config/xp-values.config.ts
================
export const XP_VALUES = {
  CODE_PUSH: {
    BASE: 120,
    BONUSES: {
      MULTIPLE_COMMITS: 250,
    },
  },
  PULL_REQUEST: {
    CREATE: {
      BASE: 100,
      BONUSES: {
        MULTIPLE_FILES: 100,
        SIGNIFICANT_CHANGES: 200,
      },
    },
    MERGE: {
      BASE: 100,
      BONUSES: {
        MULTIPLE_FILES: 100,
        SIGNIFICANT_CHANGES: 200,
      },
    },
    CLOSE: {
      BASE: 50,
      BONUSES: {
        MULTIPLE_FILES: 50,
        SIGNIFICANT_CHANGES: 100,
      },
    },
  },
  CODE_REVIEW: {
    BASE: 80,
    BONUSES: {
      DETAILED_REVIEW: 100, // For reviews with substantial comments
      MULTIPLE_FILES: 50, // For reviewing changes across multiple files
      THOROUGH_REVIEW: 150, // For reviews that include suggestions and code samples
    },
  },
};

================
File: lib/progression/commands/command-factory.ts
================
// File: libs/server/progression-engine/src/lib/progression/commands/command-factory.ts

import { GameAction } from '@codeheroes/types';
import { ProgressionService } from '../services/progression.service';
import { GameActionRepository } from '../repositories/game-action.repository';
import { ProgressionUpdate } from '../core/progression-state.model';
import { Command, ProcessGameActionCommand } from './process-game-action.command';
import { UpdateProgressionCommand } from './update-progression.command';

/**
 * Factory for creating command objects
 * Centralizes command creation and dependency injection
 */
export class CommandFactory {
  constructor(
    private progressionService: ProgressionService,
    private gameActionRepository: GameActionRepository,
  ) {}

  /**
   * Create a command to process a game action
   * @param action The game action to process
   * @returns Command object that can be executed
   */
  createProcessGameActionCommand(action: GameAction): Command<any> {
    return new ProcessGameActionCommand(action, this.progressionService, this.gameActionRepository);
  }

  /**
   * Create a command to update user progression
   * @param userId User ID to update
   * @param update The progression update to apply
   * @returns Command object that can be executed
   */
  createUpdateProgressionCommand(userId: string, update: ProgressionUpdate): Command<any> {
    return new UpdateProgressionCommand(userId, update, this.progressionService);
  }
}

================
File: lib/progression/commands/process-game-action.command.ts
================
import { logger } from '@codeheroes/common';
import { GameAction, ActionResult } from '@codeheroes/types';
import { ProgressionService } from '../services/progression.service';
import { GameActionRepository } from '../repositories/game-action.repository';

/**
 * Command interface for the command pattern
 */
export interface Command<T> {
  execute(): Promise<T>;
}

/**
 * Command for processing a game action
 * Implements command pattern for better encapsulation and testability
 */
export class ProcessGameActionCommand implements Command<ActionResult> {
  constructor(
    private action: GameAction,
    private progressionService: ProgressionService,
    private gameActionRepository: GameActionRepository,
  ) {}

  /**
   * Execute the command to process a game action
   * @returns Action processing result
   */
  async execute(): Promise<ActionResult> {
    const { id, type, userId } = this.action;

    logger.info(`Executing process game action command`, {
      actionId: id,
      actionType: type,
      userId,
    });

    try {
      // Process the action
      const result = await this.progressionService.processGameAction(this.action);

      // Mark action as processed
      await this.gameActionRepository.markAsProcessed(id);

      logger.info(`Game action processed successfully`, {
        actionId: id,
        xpGained: result.xpGained,
        newLevel: result.level,
      });

      return result;
    } catch (error) {
      logger.error(`Error processing game action`, {
        actionId: id,
        error: error instanceof Error ? error.message : String(error),
      });

      // Mark action as failed
      await this.gameActionRepository.markAsFailed(id, error instanceof Error ? error.message : 'Unknown error');

      throw error;
    }
  }
}

================
File: lib/progression/commands/update-progression.command.ts
================
import { logger } from '@codeheroes/common';
import { ActionResult } from '@codeheroes/types';
import { ProgressionService } from '../services/progression.service';
import { ProgressionUpdate } from '../core/progression-state.model';
import { Command } from './process-game-action.command';

/**
 * Command for manually updating user progression
 * Implements command pattern for better encapsulation and testability
 */
export class UpdateProgressionCommand implements Command<ActionResult> {
  constructor(
    private userId: string,
    private update: ProgressionUpdate,
    private progressionService: ProgressionService,
  ) {}

  /**
   * Execute the command to update user progression
   * @returns Action result with updated progression details
   */
  async execute(): Promise<ActionResult> {
    logger.info(`Executing update progression command`, {
      userId: this.userId,
      xpGained: this.update.xpGained,
      activityType: this.update.activityType,
    });

    try {
      // Update progression through the service
      const result = await this.progressionService.updateProgression(this.userId, this.update);

      logger.info(`Progression updated successfully`, {
        userId: this.userId,
        xpGained: this.update.xpGained,
        newLevel: result.level,
      });

      return result;
    } catch (error) {
      logger.error(`Error updating progression`, {
        userId: this.userId,
        error: error instanceof Error ? error.message : String(error),
      });

      throw error;
    }
  }
}

================
File: lib/progression/core/progression-events.model.ts
================
import { Activity } from '@codeheroes/types';
import { ProgressionState } from './progression-state.model';

/**
 * Types of progression events that can be published
 */
export enum ProgressionEventType {
  XP_GAINED = 'progression.xp.gained',
  LEVEL_UP = 'progression.level.up',
  BADGE_EARNED = 'progression.badge.earned',
  ACTIVITY_RECORDED = 'progression.activity.recorded',
  ACHIEVEMENT_UNLOCKED = 'progression.achievement.unlocked',
  STREAK_MILESTONE = 'progression.streak.milestone',
}

/**
 * Base interface for all progression events
 */
export interface ProgressionEvent {
  /** User ID that the event relates to */
  userId: string;

  /** Timestamp when the event occurred */
  timestamp: string;

  /** Type of progression event */
  type: ProgressionEventType;

  /** Event-specific data */
  data: Record<string, any>;
}

/**
 * Event published when a user gains XP
 */
export interface XpGainedEvent extends ProgressionEvent {
  type: ProgressionEventType.XP_GAINED;
  data: {
    /** Amount of XP gained */
    xpGained: number;

    /** Activity that generated the XP */
    activity?: Activity;

    /** New progression state */
    state: ProgressionState;

    /** Previous progression state */
    previousState: ProgressionState;
  };
}

/**
 * Event published when a user levels up
 */
export interface LevelUpEvent extends ProgressionEvent {
  type: ProgressionEventType.LEVEL_UP;
  data: {
    /** Previous level */
    previousLevel: number;

    /** New level */
    newLevel: number;

    /** New progression state */
    state: ProgressionState;

    /** Rewards earned for the level-up */
    rewards?: {
      badges?: string[];
      unlocks?: string[];
    };
  };
}

/**
 * Event published when a user earns a badge
 */
export interface BadgeEarnedEvent extends ProgressionEvent {
  type: ProgressionEventType.BADGE_EARNED;
  data: {
    /** ID of the earned badge */
    badgeId: string;

    /** Name of the earned badge */
    badgeName: string;

    /** Description of the earned badge */
    badgeDescription?: string;
  };
}

/**
 * Event published when an activity is recorded
 */
export interface ActivityRecordedEvent extends ProgressionEvent {
  type: ProgressionEventType.ACTIVITY_RECORDED;
  data: {
    /** The recorded activity */
    activity: Activity;
  };
}

/**
 * Type union of all progression event interfaces
 */
export type ProgressionEventUnion = XpGainedEvent | LevelUpEvent | BadgeEarnedEvent | ActivityRecordedEvent;

================
File: lib/progression/core/progression-state.model.ts
================
import { ActivityCounters } from '@codeheroes/types';

/**
 * Represents the current progression state of a user
 */
export interface ProgressionState {
  /** Unique identifier of the progression state */
  id: string;

  /** Unique identifier of the user */
  userId: string;

  /** Total experience points earned by the user */
  xp: number;

  /** Current level of the user */
  level: number;

  /** XP earned in the current level */
  currentLevelXp: number;

  /** XP needed to reach the next level */
  xpToNextLevel: number;

  /** Date of the last user activity (YYYY-MM-DD format) */
  lastActivityDate: string | null;

  /** Counters for different activity types */
  counters: ActivityCounters;

  /** Timestamp when counters were last updated */
  countersLastUpdated: string;

  /** Optional array of achievement IDs earned by the user */
  achievements?: string[];
}

/**
 * Parameters for updating a user's progression state
 */
export interface ProgressionUpdate {
  /** Amount of XP to add to the user's total */
  xpGained: number;

  /** Type of activity that generated the XP */
  activityType?: string;

  /** Optional array of new achievements earned from this update */
  achievements?: string[];
}

/**
 * Result of a progression update operation
 */
export interface ProgressionUpdateResult {
  /** New progression state after the update */
  state: ProgressionState;

  /** Previous progression state before the update */
  previousState: ProgressionState;

  /** Whether the user leveled up during this update */
  leveledUp: boolean;

  /** Any achievements earned during this update */
  newAchievements?: string[];
}

================
File: lib/progression/core/service-registry.ts
================
import { DatabaseInstance } from '@codeheroes/common';
import { EventPublisherService } from '../events/event-publisher.service';
import { ActionHandlerFactory } from '../handlers/action-handler.factory';
import { ActivityRepository } from '../repositories/activity.repository';
import { GameActionRepository } from '../repositories/game-action.repository';
import { ProgressionRepository } from '../repositories/progression.repository';
import { ActivityRecorderService } from '../services/activity-recorder.service';
import { ProgressionService } from '../services/progression.service';
import { XpCalculatorService } from '../services/xp-calculator.service';
/**
 * Service registry containing all progression-related services
 * Acts as a simple dependency injection container
 */
export interface ServiceRegistry {
  progressionStateRepository: ProgressionRepository;
  activityRepository: ActivityRepository;
  gameActionRepository: GameActionRepository;
  xpCalculatorService: XpCalculatorService;
  activityRecorderService: ActivityRecorderService;
  eventPublisherService: EventPublisherService;
  progressionService: ProgressionService;
}

/**
 * Creates a service registry with all dependencies properly initialized
 * @returns Service registry object with all services
 */
export function createServiceRegistry(): ServiceRegistry {
  // Initialize Firestore instance
  const db = DatabaseInstance.getInstance();

  // Create repositories
  const progressionStateRepository = new ProgressionRepository(db);
  const activityRepository = new ActivityRepository(db);
  const gameActionRepository = new GameActionRepository(db);

  // Create supporting services
  const xpCalculatorService = new XpCalculatorService();
  const activityRecorderService = new ActivityRecorderService();
  const eventPublisherService = new EventPublisherService();

  // Create main progression service with all dependencies
  const progressionService = new ProgressionService(
    progressionStateRepository,
    activityRepository,
    gameActionRepository,
    xpCalculatorService,
    activityRecorderService,
    eventPublisherService,
  );

  // Initialize action handlers
  ActionHandlerFactory.initialize(db, progressionService);

  // Return the registry with all services
  return {
    progressionStateRepository,
    activityRepository,
    gameActionRepository,
    xpCalculatorService,
    activityRecorderService,
    eventPublisherService,
    progressionService,
  };
}

================
File: lib/progression/core/xp-calculation.model.ts
================
import { GameActionType } from '@codeheroes/types';

/**
 * Result of an XP calculation
 */
export interface XpCalculationResult {
  /** Base XP amount for the action type */
  baseXp: number;

  /** Additional XP from bonuses */
  bonusXp: number;

  /** Total XP (base + bonus) */
  total: number;

  /** Detailed breakdown of XP sources */
  breakdown: XpBreakdownItem[];
}

/**
 * Single item in an XP breakdown
 */
export interface XpBreakdownItem {
  /** Type/source of XP */
  type: string;

  /** Amount of XP from this source */
  amount: number;

  /** User-friendly description of this XP source */
  description: string;
}

/**
 * Configuration for XP values by action type
 */
export interface XpConfig {
  /** Base XP values for each action type */
  baseValues: Record<GameActionType, number>;

  /** Bonus XP multipliers for different contexts */
  bonuses: {
    /** Multiplier for consecutive activities */
    streak: number;

    /** Multiplier for first daily activity */
    firstDaily: number;

    /** Specific bonuses by action type */
    byType: Partial<Record<GameActionType, number>>;
  };

  /** Caps and limits */
  limits: {
    /** Maximum daily XP */
    maxDailyXp?: number;

    /** Maximum XP per action type */
    maxPerActionType?: Partial<Record<GameActionType, number>>;
  };
}

================
File: lib/progression/events/event-processor.service.ts
================
import { DatabaseInstance, logger } from '@codeheroes/common';
import { NotificationService } from '@codeheroes/notifications';
import { Collections, ProgressionEvent, ProgressionEventType } from '@codeheroes/types';
import { Firestore } from 'firebase-admin/firestore';
import { BadgeService } from '../../rewards/services/badge.service';

/**
 * Service responsible for processing progression events
 */
export class EventProcessorService {
  private db: Firestore;
  private notificationService: NotificationService;
  private badgeService: BadgeService;

  constructor() {
    this.db = DatabaseInstance.getInstance();
    this.notificationService = new NotificationService();
    // Pass this instance to BadgeService to prevent circular instantiation
    this.badgeService = new BadgeService(this);
  }

  /**
   * Handle a progression event
   * @param event The progression event to handle
   */
  async handleEvent(event: ProgressionEvent): Promise<void> {
    logger.info('Handling progression event', { type: event.type, userId: event.userId });

    switch (event.type) {
      case ProgressionEventType.LEVEL_UP:
        await this.handleLevelUp(event);
        break;
      case ProgressionEventType.BADGE_EARNED:
        await this.handleBadgeEarned(event);
        break;
      case ProgressionEventType.ACTIVITY_RECORDED:
        await this.handleActivityRecorded(event);
        break;
      case ProgressionEventType.XP_GAINED:
        await this.handleXpGained(event);
        break;
    }
  }

  /**
   * Handle level up events
   * @param event Level up event
   */
  private async handleLevelUp(event: ProgressionEvent): Promise<void> {
    const { userId, data } = event;
    const newLevel = data.state?.level;
    if (!newLevel) return;

    await this.db.runTransaction(async (transaction) => {
      const userRef = this.db.collection(Collections.Users).doc(userId);
      const achievementRef = userRef.collection(Collections.Achievements);

      // Record achievement
      await this.recordAchievement(transaction, achievementRef, {
        id: `level_${newLevel}`,
        name: `Level ${newLevel}`,
        description: `Reached level ${newLevel}`,
        timestamp: event.timestamp,
      });

      // Level-based achievements
      if (newLevel === 5) {
        await this.recordAchievement(transaction, achievementRef, {
          id: 'intermediate_hero',
          name: 'Intermediate Hero',
          description: 'Reached level 5',
          timestamp: event.timestamp,
        });
      } else if (newLevel === 10) {
        await this.recordAchievement(transaction, achievementRef, {
          id: 'advanced_hero',
          name: 'Advanced Hero',
          description: 'Reached level 10',
          timestamp: event.timestamp,
        });
      }

      await this.notificationService.createNotification(userId, {
        type: 'LEVEL_UP',
        title: 'Level Up!',
        message: `Congratulations! You've reached level ${newLevel}!`,
        metadata: { level: newLevel },
      });
    });
  }

  /**
   * Handle badge earned events
   * @param event Badge earned event
   */
  private async handleBadgeEarned(event: ProgressionEvent): Promise<void> {
    const { userId, data } = event;
    const badgeId = data.badgeId;
    if (!badgeId) return;

    await this.db.runTransaction(async (transaction) => {
      const userRef = this.db.collection(Collections.Users).doc(userId);
      const userBadges = await transaction.get(userRef.collection(Collections.Badges));

      const badgeCount = userBadges.size;
      const achievementRef = userRef.collection(Collections.Achievements);

      await this.notificationService.createNotification(userId, {
        type: 'BADGE_EARNED',
        title: 'New Badge!',
        message: `You've earned a new badge!`,
        metadata: { badgeId },
      });

      if (badgeCount === 5) {
        await this.recordAchievement(transaction, achievementRef, {
          id: 'badge_collector',
          name: 'Badge Collector',
          description: 'Earned 5 different badges',
          timestamp: event.timestamp,
        });
      } else if (badgeCount === 10) {
        await this.recordAchievement(transaction, achievementRef, {
          id: 'badge_master',
          name: 'Badge Master',
          description: 'Earned 10 different badges',
          timestamp: event.timestamp,
        });
      }
    });
  }

  /**
   * Handle activity recorded events
   * @param event Activity recorded event
   */
  private async handleActivityRecorded(event: ProgressionEvent): Promise<void> {
    const { userId, data } = event;
    const activity = data.activity;
    if (!activity) return;

    try {
      // Use sourceActionType instead of the type property
      const actionType = activity.sourceActionType;
      const stats = await this.getActivityStats(userId, actionType);
      const userRef = this.db.collection(Collections.Users).doc(userId);
      const achievementRef = userRef.collection(Collections.Achievements);

      // First-time achievements
      if (stats.total === 1) {
        await this.recordAchievement(null, achievementRef, {
          id: `first_${actionType}`,
          name: `First ${actionType.replace(/_/g, ' ')}`,
          description: `Completed your first ${actionType.replace(/_/g, ' ')}`,
          timestamp: event.timestamp,
        });
      }

      // Milestone achievements
      const milestones = [10, 50, 100, 500];
      const nextMilestone = milestones.find((m) => stats.total === m);
      if (nextMilestone) {
        await this.recordAchievement(null, achievementRef, {
          id: `${actionType}_milestone_${nextMilestone}`,
          name: `${actionType.replace(/_/g, ' ')} Master ${nextMilestone}`,
          description: `Completed ${nextMilestone} ${actionType.replace(/_/g, ' ')}s`,
          timestamp: event.timestamp,
        });
      }
    } catch (error) {
      logger.error('Error processing activity recorded event:', error);
      throw error;
    }
  }

  /**
   * Handle XP gained events
   * @param event XP gained event
   */
  private async handleXpGained(event: ProgressionEvent): Promise<void> {
    // Handle XP gained events if needed
    // Most XP-related processing is handled by the progression service
  }

  /**
   * Record an achievement
   * @param transaction Firestore transaction or null
   * @param achievementRef Reference to achievements collection
   * @param achievement Achievement data to record
   */
  private async recordAchievement(
    transaction: FirebaseFirestore.Transaction | null,
    achievementRef: FirebaseFirestore.CollectionReference,
    achievement: {
      id: string;
      name: string;
      description: string;
      timestamp: string;
    },
  ): Promise<void> {
    const docRef = achievementRef.doc(achievement.id);

    if (transaction) {
      transaction.set(docRef, achievement);
    } else {
      await docRef.set(achievement);
    }
  }

  /**
   * Get activity stats for a user and activity type
   * @param userId User ID
   * @param activityType Activity type
   * @returns Activity stats
   */
  private async getActivityStats(userId: string, activityType: string): Promise<{ total: number }> {
    const userRef = this.db.collection(Collections.Users).doc(userId);
    const statsDoc = await userRef.collection(Collections.Stats).doc('current').get();
    const stats = statsDoc.data()?.activityStats || {};
    return {
      total: stats.byType?.[activityType] || 0,
    };
  }
}

================
File: lib/progression/events/event-publisher.service.ts
================
import { logger } from '@codeheroes/common';
import { Activity, ProgressionEvent, ProgressionEventType, ProgressionState } from '@codeheroes/types';
import { PubSub } from '@google-cloud/pubsub';

/**
 * Service responsible for publishing progression events to Pub/Sub
 */
export class EventPublisherService {
  private pubsub: PubSub;
  private readonly topicName = 'progression-events';

  constructor() {
    this.pubsub = new PubSub();
  }

  /**
   * Emit an XP gained event
   * @param userId User ID who gained XP
   * @param activity Activity that generated the XP
   * @param state Current progression state
   * @param previousState Previous progression state
   */
  async emitXpGained(
    userId: string,
    activity: Activity,
    state: ProgressionState,
    previousState: ProgressionState,
  ): Promise<void> {
    await this.emit({
      userId,
      timestamp: new Date().toISOString(),
      type: ProgressionEventType.XP_GAINED,
      data: {
        activity,
        state,
        previousState,
        xpGained: activity.xp.earned,
      },
    });

    logger.debug('XP gained event published', {
      userId,
      xpGained: activity.xp.earned,
    });
  }

  /**
   * Emit a level up event
   * @param userId User ID who leveled up
   * @param state Current progression state
   * @param previousState Previous progression state
   */
  async emitLevelUp(userId: string, state: ProgressionState, previousState: ProgressionState): Promise<void> {
    await this.emit({
      userId,
      timestamp: new Date().toISOString(),
      type: ProgressionEventType.LEVEL_UP,
      data: {
        state,
        previousState,
        previousLevel: previousState.level,
        newLevel: state.level,
      },
    });

    logger.info('Level up event published', {
      userId,
      previousLevel: previousState.level,
      newLevel: state.level,
    });
  }

  /**
   * Emit a badge earned event
   * @param userId User ID who earned the badge
   * @param badgeId ID of the earned badge
   * @param state Current progression state
   */
  async emitBadgeEarned(userId: string, badgeId: string, state: ProgressionState): Promise<void> {
    await this.emit({
      userId,
      timestamp: new Date().toISOString(),
      type: ProgressionEventType.BADGE_EARNED,
      data: {
        badgeId,
        state,
      },
    });

    logger.info('Badge earned event published', {
      userId,
      badgeId,
    });
  }

  /**
   * Emit an achievement unlocked event
   * @param userId User ID who unlocked the achievement
   * @param achievementId ID of the unlocked achievement
   */
  async emitAchievementUnlocked(userId: string, achievementId: string): Promise<void> {
    await this.emit({
      userId,
      timestamp: new Date().toISOString(),
      type: ProgressionEventType.ACHIEVEMENT_UNLOCKED,
      data: {
        achievementId,
      },
    });

    logger.info('Achievement unlocked event published', {
      userId,
      achievementId,
    });
  }

  /**
   * Emit an activity recorded event
   * @param userId User ID whose activity was recorded
   * @param activity The recorded activity
   */
  async emitActivityRecorded(userId: string, activity: Activity): Promise<void> {
    await this.emit({
      userId,
      timestamp: new Date().toISOString(),
      type: ProgressionEventType.ACTIVITY_RECORDED,
      data: {
        activity,
      },
    });

    logger.debug('Activity recorded event published', {
      userId,
      activityId: activity.id,
      activityType: activity.sourceActionType,
    });
  }

  /**
   * Emit a progression event to Pub/Sub
   * @param event Progression event to publish
   */
  private async emit(event: ProgressionEvent): Promise<void> {
    try {
      const topic = this.pubsub.topic(this.topicName);
      const data = Buffer.from(JSON.stringify(event));
      await topic.publish(data);
    } catch (error) {
      logger.error('Error publishing progression event', {
        eventType: event.type,
        userId: event.userId,
        error: error instanceof Error ? error.message : String(error),
      });

      // Don't throw the error to prevent blocking the main flow
      // Just log it and continue
    }
  }
}

================
File: lib/progression/handlers/actions/code-push.handler.ts
================
import { GameActionContext, GameActionMetrics, GameActionType } from '@codeheroes/types';
import { Firestore } from 'firebase-admin/firestore';
import { XP_VALUES } from '../../../config/xp-values.config';
import { AbstractActionHandler } from '../action-handler.base';
import { ProgressionService } from '../../services/progression.service';

/**
 * Handler for code push actions
 */
export class CodePushHandler extends AbstractActionHandler {
  protected actionType: GameActionType = 'code_push';

  constructor(
    protected db: Firestore,
    protected progressionService: ProgressionService,
  ) {
    super(db, progressionService);
  }

  /**
   * Calculate bonuses for code push actions
   * @param context Action context
   * @param metrics Action metrics
   * @returns Calculated bonuses
   */
  calculateBonuses(
    context: GameActionContext,
    metrics?: GameActionMetrics,
  ): {
    totalBonus: number;
    breakdown: Record<string, number>;
  } {
    const bonuses: Record<string, number> = {};
    let totalBonus = 0;

    // Extract commit count from metrics if available
    const commitCount = metrics && 'commitCount' in metrics ? metrics.commitCount : 1;

    // Multiple commits bonus
    if (commitCount > 1) {
      bonuses.multipleCommits = XP_VALUES.CODE_PUSH.BONUSES.MULTIPLE_COMMITS;
      totalBonus += bonuses.multipleCommits;
    }

    // Branch creation bonus
    if (context.type === 'code_push' && context.isNew) {
      bonuses.newBranch = 100; // Bonus for creating a new branch
      totalBonus += bonuses.newBranch;
    }

    // Additional bonuses could be added here based on other metrics

    return {
      totalBonus,
      breakdown: bonuses,
    };
  }
}

================
File: lib/progression/handlers/actions/code-review.handler.ts
================
import { GameActionContext, GameActionMetrics, GameActionType } from '@codeheroes/types';
import { Firestore } from 'firebase-admin/firestore';
import { XP_VALUES } from '../../../config/xp-values.config';
import { AbstractActionHandler } from '../action-handler.base';
import { ProgressionService } from '../../services/progression.service';

/**
 * Handler for code review actions
 */
export class CodeReviewSubmitHandler extends AbstractActionHandler {
  protected actionType: GameActionType = 'code_review_submit';

  constructor(
    protected db: Firestore,
    protected progressionService: ProgressionService,
  ) {
    super(db, progressionService);
  }

  /**
   * Calculate bonuses for code review actions
   * @param context Action context
   * @param metrics Action metrics
   * @returns Calculated bonuses
   */
  calculateBonuses(
    context: GameActionContext,
    metrics?: GameActionMetrics,
  ): {
    totalBonus: number;
    breakdown: Record<string, number>;
  } {
    const bonuses: Record<string, number> = {};
    let totalBonus = 0;

    // Detailed review bonus (if there are significant comments)
    if (metrics && 'commentsCount' in metrics && metrics.commentsCount >= 3) {
      bonuses.detailedReview = XP_VALUES.CODE_REVIEW.BONUSES.DETAILED_REVIEW;
      totalBonus += bonuses.detailedReview;
    }

    // Multiple files bonus
    if (metrics && 'filesReviewed' in metrics && metrics.filesReviewed > 3) {
      bonuses.multipleFiles = XP_VALUES.CODE_REVIEW.BONUSES.MULTIPLE_FILES;
      totalBonus += bonuses.multipleFiles;
    }

    // Thorough review bonus (based on suggestions made)
    if (metrics && 'suggestionsCount' in metrics && metrics.suggestionsCount > 0) {
      bonuses.thoroughReview = XP_VALUES.CODE_REVIEW.BONUSES.THOROUGH_REVIEW;
      totalBonus += bonuses.thoroughReview;
    }

    // Additional bonuses for high quality reviews
    if (context.type === 'code_review' && context.review.state === 'approved') {
      bonuses.approvalBonus = 50; // Bonus for approving the PR
      totalBonus += bonuses.approvalBonus;
    }

    return {
      totalBonus,
      breakdown: bonuses,
    };
  }
}

================
File: lib/progression/handlers/actions/pull-request.handler.ts
================
import { GameActionContext, GameActionMetrics, GameActionType } from '@codeheroes/types';
import { Firestore } from 'firebase-admin/firestore';
import { XP_VALUES } from '../../../config/xp-values.config';
import { AbstractActionHandler } from '../action-handler.base';
import { ProgressionService } from '../../services/progression.service';

/**
 * Handler for pull request actions (create, merge, close)
 */
export class PullRequestCreateHandler extends AbstractActionHandler {
  protected actionType: GameActionType;

  /**
   * Create a new pull request handler
   * @param db Firestore instance
   * @param action 'create', 'merge', or 'close'
   */
  constructor(
    protected db: Firestore,
    protected progressionService: ProgressionService,
    private action: 'create' | 'merge' | 'close',
  ) {
    super(db, progressionService);

    // Set the action type based on the action parameter
    if (action === 'create') {
      this.actionType = 'pull_request_create';
    } else if (action === 'merge') {
      this.actionType = 'pull_request_merge';
    } else {
      this.actionType = 'pull_request_close';
    }
  }

  /**
   * Calculate bonuses for pull request actions
   * @param context Action context
   * @param metrics Action metrics
   * @returns Calculated bonuses
   */
  calculateBonuses(
    context: GameActionContext,
    metrics?: GameActionMetrics,
  ): {
    totalBonus: number;
    breakdown: Record<string, number>;
  } {
    const bonuses: Record<string, number> = {};
    let totalBonus = 0;

    // Get the correct bonus values based on action type
    let xpValues;
    if (this.actionType === 'pull_request_create') {
      xpValues = XP_VALUES.PULL_REQUEST.CREATE;
    } else if (this.actionType === 'pull_request_merge') {
      xpValues = XP_VALUES.PULL_REQUEST.MERGE;
    } else {
      xpValues = XP_VALUES.PULL_REQUEST.CLOSE;
    }

    // Multiple files bonus
    if (metrics && 'changedFiles' in metrics && metrics.changedFiles > 3) {
      bonuses.multipleFiles = xpValues.BONUSES.MULTIPLE_FILES;
      totalBonus += bonuses.multipleFiles;
    }

    // Significant changes bonus
    if (metrics && 'additions' in metrics && 'deletions' in metrics) {
      const totalChanges = metrics.additions + metrics.deletions;
      if (totalChanges > 100) {
        bonuses.significantChanges = xpValues.BONUSES.SIGNIFICANT_CHANGES;
        totalBonus += bonuses.significantChanges;
      }
    }

    // Additional metrics-based bonuses could be added here

    return {
      totalBonus,
      breakdown: bonuses,
    };
  }
}

================
File: lib/progression/handlers/action-handler.base.ts
================
import { GameActionContext, GameActionMetrics, GameActionType } from '@codeheroes/types';
import { Firestore } from 'firebase-admin/firestore';
import { ProgressionService } from '../services/progression.service';

/**
 * Base class for all game action handlers
 */
export abstract class AbstractActionHandler {
  /**
   * The action type this handler is responsible for
   */
  protected abstract actionType: GameActionType;

  /**
   * Create a new action handler
   * @param db Firestore instance
   */
  constructor(
    protected db: Firestore,
    protected progressionService: ProgressionService,
  ) {}

  /**
   * Calculate bonuses for the action based on context and metrics
   * @param context Action context containing details about where the action occurred
   * @param metrics Action metrics containing measurements about the action
   * @returns Calculated bonuses with breakdown
   */
  abstract calculateBonuses(
    context: GameActionContext,
    metrics?: GameActionMetrics,
  ): {
    totalBonus: number;
    breakdown: Record<string, number>;
  };

  /**
   * Get the action type handled by this handler
   * @returns The action type
   */
  getActionType(): GameActionType {
    return this.actionType;
  }
}

================
File: lib/progression/handlers/action-handler.factory.ts
================
import { GameActionType } from '@codeheroes/types';
import { Firestore } from 'firebase-admin/firestore';
import { AbstractActionHandler } from './action-handler.base';
import { CodePushHandler } from './actions/code-push.handler';
import { PullRequestCreateHandler } from './actions/pull-request.handler';
import { CodeReviewSubmitHandler } from './actions/code-review.handler';
import { ProgressionService } from '../services/progression.service';

/**
 * Factory for creating action handlers based on action type
 */
export class ActionHandlerFactory {
  private static db: Firestore;
  private static handlers: Map<GameActionType, AbstractActionHandler>;
  private static initialized = false;

  /**
   * Initialize the factory with Firestore instance and handlers
   * @param db Firestore instance
   */
  static initialize(db: Firestore, progressionService: ProgressionService): void {
    this.db = db;
    this.handlers = new Map();

    // Register all handlers, passing the progression service
    this.handlers.set('code_push', new CodePushHandler(db, progressionService));
    this.handlers.set('pull_request_create', new PullRequestCreateHandler(db, progressionService, 'create'));
    this.handlers.set('pull_request_merge', new PullRequestCreateHandler(db, progressionService, 'merge'));
    this.handlers.set('pull_request_close', new PullRequestCreateHandler(db, progressionService, 'close'));
    this.handlers.set('code_review_submit', new CodeReviewSubmitHandler(db, progressionService));

    this.initialized = true;
  }

  /**
   * Get appropriate handler for an action type
   * @param actionType Game action type
   * @returns Action handler for the specified type
   * @throws Error if factory not initialized or handler not found
   */
  static getHandler(actionType: GameActionType): AbstractActionHandler {
    if (!this.initialized) {
      throw new Error('ActionHandlerFactory not initialized. Call initialize() first.');
    }

    const handler = this.handlers.get(actionType);
    if (!handler) {
      throw new Error(`No handler found for action type: ${actionType}`);
    }

    return handler;
  }

  /**
   * Check if a handler exists for the given action type
   * @param actionType Game action type to check
   * @returns True if a handler exists
   */
  static hasHandlerFor(actionType: GameActionType): boolean {
    return this.initialized && this.handlers.has(actionType);
  }

  /**
   * Get all supported action types
   * @returns Array of supported action types
   */
  static getSupportedActionTypes(): GameActionType[] {
    return this.initialized ? Array.from(this.handlers.keys()) : [];
  }
}

================
File: lib/progression/repositories/activity.repository.ts
================
import { BaseRepository, getCurrentTimeAsISO, logger } from '@codeheroes/common';
import { Collections, GameAction, GameActionType } from '@codeheroes/types';
import { Firestore } from 'firebase-admin/firestore';

/**
 * Repository for managing game actions in Firestore
 */
export class GameActionRepository extends BaseRepository<GameAction> {
  protected collectionPath = Collections.GameActions;

  constructor(db: Firestore) {
    super(db);
  }

  /**
   * Creates a new game action
   * @param gameAction The game action to create (without ID)
   * @returns The created game action with ID
   */
  async createGameAction(
    gameAction: Omit<GameAction, 'id' | 'status' | 'createdAt' | 'updatedAt'>,
  ): Promise<GameAction> {
    logger.debug('Creating game action', {
      userId: gameAction.userId,
      type: gameAction.type,
    });

    try {
      const docRef = this.db.collection(this.collectionPath).doc();
      const now = getCurrentTimeAsISO();

      const newGameAction: GameAction = {
        ...(gameAction as GameAction),
        id: docRef.id,
        status: 'pending',
        createdAt: now,
        updatedAt: now,
      };

      await docRef.set(newGameAction);

      logger.debug('Game action created successfully', {
        id: newGameAction.id,
        type: newGameAction.type,
      });

      return newGameAction;
    } catch (error) {
      logger.error('Error creating game action', { error });
      throw error;
    }
  }

  /**
   * Marks a game action as processed
   * @param id Game action ID to mark as processed
   */
  async markAsProcessed(id: string): Promise<void> {
    try {
      await this.db.collection(this.collectionPath).doc(id).update({
        status: 'processed',
        processedAt: getCurrentTimeAsISO(),
        updatedAt: getCurrentTimeAsISO(),
      });

      logger.debug('Game action marked as processed', { id });
    } catch (error) {
      logger.error('Error marking game action as processed', { id, error });
      throw error;
    }
  }

  /**
   * Marks a game action as failed
   * @param id Game action ID to mark as failed
   * @param errorMessage Error message to store
   */
  async markAsFailed(id: string, errorMessage: string): Promise<void> {
    try {
      await this.db.collection(this.collectionPath).doc(id).update({
        status: 'failed',
        error: errorMessage,
        updatedAt: getCurrentTimeAsISO(),
      });

      logger.debug('Game action marked as failed', { id, error: errorMessage });
    } catch (error) {
      logger.error('Error marking game action as failed', { id, error });
      throw error;
    }
  }

  /**
   * Gets a game action by ID
   * @param id Game action ID to retrieve
   * @returns The game action or null if not found
   */
  async getGameAction(id: string): Promise<GameAction | null> {
    try {
      const doc = await this.db.collection(this.collectionPath).doc(id).get();

      return doc.exists ? (doc.data() as GameAction) : null;
    } catch (error) {
      logger.error('Error getting game action', { id, error });
      throw error;
    }
  }

  /**
   * Finds pending game actions for processing
   * @param limit Maximum number of actions to return
   * @returns Array of pending game actions
   */
  async findPendingGameActions(limit = 10): Promise<GameAction[]> {
    try {
      const snapshot = await this.db
        .collection(this.collectionPath)
        .where('status', '==', 'pending')
        .orderBy('createdAt')
        .limit(limit)
        .get();

      return snapshot.docs.map((doc) => doc.data() as GameAction);
    } catch (error) {
      logger.error('Error finding pending game actions', { error });
      throw error;
    }
  }

  /**
   * Finds recent game actions for a user
   * @param userId User ID to find actions for
   * @param limit Maximum number of actions to return
   * @returns Array of game actions ordered by timestamp (newest first)
   */
  async findRecentByUser(userId: string, limit = 10): Promise<GameAction[]> {
    try {
      const snapshot = await this.db
        .collection(this.collectionPath)
        .where('userId', '==', userId)
        .orderBy('timestamp', 'desc')
        .limit(limit)
        .get();

      return snapshot.docs.map((doc) => doc.data() as GameAction);
    } catch (error) {
      logger.error('Error finding recent game actions for user', { userId, error });
      throw error;
    }
  }

  /**
   * Finds actions by type
   * @param type Game action type
   * @param limit Maximum number of actions to return
   * @returns Array of game actions of the specified type
   */
  async findByType(type: GameActionType, limit = 50): Promise<GameAction[]> {
    try {
      const snapshot = await this.db
        .collection(this.collectionPath)
        .where('type', '==', type)
        .orderBy('timestamp', 'desc')
        .limit(limit)
        .get();

      return snapshot.docs.map((doc) => doc.data() as GameAction);
    } catch (error) {
      logger.error('Error finding game actions by type', { type, error });
      throw error;
    }
  }

  /**
   * Finds actions by external ID
   * @param externalId External ID to search for
   * @returns Array of matching game actions
   */
  async findByExternalId(externalId: string): Promise<GameAction[]> {
    try {
      const snapshot = await this.db.collection(this.collectionPath).where('externalId', '==', externalId).get();

      return snapshot.docs.map((doc) => doc.data() as GameAction);
    } catch (error) {
      logger.error('Error finding game actions by external ID', { externalId, error });
      throw error;
    }
  }

  /**
   * Counts actions by status
   * @param status Status to count
   * @returns Count of actions with the specified status
   */
  async countByStatus(status: 'pending' | 'processed' | 'failed'): Promise<number> {
    try {
      const snapshot = await this.db.collection(this.collectionPath).where('status', '==', status).count().get();

      return snapshot.data().count;
    } catch (error) {
      logger.error('Error counting game actions by status', { status, error });
      throw error;
    }
  }
}

================
File: lib/progression/repositories/game-action.repository.ts
================
import { BaseRepository, getCurrentTimeAsISO, logger } from '@codeheroes/common';
import { Collections, GameAction, GameActionType } from '@codeheroes/types';
import { Firestore } from 'firebase-admin/firestore';

/**
 * Repository for managing game actions in Firestore
 */
export class GameActionRepository extends BaseRepository<GameAction> {
  protected collectionPath = Collections.GameActions;

  constructor(db: Firestore) {
    super(db);
  }

  /**
   * Creates a new game action
   * @param gameAction The game action to create (without ID)
   * @returns The created game action with ID
   */
  async createGameAction(
    gameAction: Omit<GameAction, 'id' | 'status' | 'createdAt' | 'updatedAt'>,
  ): Promise<GameAction> {
    logger.debug('Creating game action', {
      userId: gameAction.userId,
      type: gameAction.type,
    });

    try {
      const docRef = this.db.collection(this.collectionPath).doc();
      const now = getCurrentTimeAsISO();

      const newGameAction: GameAction = {
        ...(gameAction as GameAction),
        id: docRef.id,
        status: 'pending',
        createdAt: now,
        updatedAt: now,
      };

      await docRef.set(newGameAction);

      logger.debug('Game action created successfully', {
        id: newGameAction.id,
        type: newGameAction.type,
      });

      return newGameAction;
    } catch (error) {
      logger.error('Error creating game action', { error });
      throw error;
    }
  }

  /**
   * Marks a game action as processed
   * @param id Game action ID to mark as processed
   */
  async markAsProcessed(id: string): Promise<void> {
    try {
      await this.db.collection(this.collectionPath).doc(id).update({
        status: 'processed',
        processedAt: getCurrentTimeAsISO(),
        updatedAt: getCurrentTimeAsISO(),
      });

      logger.debug('Game action marked as processed', { id });
    } catch (error) {
      logger.error('Error marking game action as processed', { id, error });
      throw error;
    }
  }

  /**
   * Marks a game action as failed
   * @param id Game action ID to mark as failed
   * @param errorMessage Error message to store
   */
  async markAsFailed(id: string, errorMessage: string): Promise<void> {
    try {
      await this.db.collection(this.collectionPath).doc(id).update({
        status: 'failed',
        error: errorMessage,
        updatedAt: getCurrentTimeAsISO(),
      });

      logger.debug('Game action marked as failed', { id, error: errorMessage });
    } catch (error) {
      logger.error('Error marking game action as failed', { id, error });
      throw error;
    }
  }

  /**
   * Gets a game action by ID
   * @param id Game action ID to retrieve
   * @returns The game action or null if not found
   */
  async getGameAction(id: string): Promise<GameAction | null> {
    try {
      const doc = await this.db.collection(this.collectionPath).doc(id).get();

      return doc.exists ? (doc.data() as GameAction) : null;
    } catch (error) {
      logger.error('Error getting game action', { id, error });
      throw error;
    }
  }

  /**
   * Finds pending game actions for processing
   * @param limit Maximum number of actions to return
   * @returns Array of pending game actions
   */
  async findPendingGameActions(limit = 10): Promise<GameAction[]> {
    try {
      const snapshot = await this.db
        .collection(this.collectionPath)
        .where('status', '==', 'pending')
        .orderBy('createdAt')
        .limit(limit)
        .get();

      return snapshot.docs.map((doc) => doc.data() as GameAction);
    } catch (error) {
      logger.error('Error finding pending game actions', { error });
      throw error;
    }
  }

  /**
   * Finds recent game actions for a user
   * @param userId User ID to find actions for
   * @param limit Maximum number of actions to return
   * @returns Array of game actions ordered by timestamp (newest first)
   */
  async findRecentByUser(userId: string, limit = 10): Promise<GameAction[]> {
    try {
      const snapshot = await this.db
        .collection(this.collectionPath)
        .where('userId', '==', userId)
        .orderBy('timestamp', 'desc')
        .limit(limit)
        .get();

      return snapshot.docs.map((doc) => doc.data() as GameAction);
    } catch (error) {
      logger.error('Error finding recent game actions for user', { userId, error });
      throw error;
    }
  }

  /**
   * Finds actions by type
   * @param type Game action type
   * @param limit Maximum number of actions to return
   * @returns Array of game actions of the specified type
   */
  async findByType(type: GameActionType, limit = 50): Promise<GameAction[]> {
    try {
      const snapshot = await this.db
        .collection(this.collectionPath)
        .where('type', '==', type)
        .orderBy('timestamp', 'desc')
        .limit(limit)
        .get();

      return snapshot.docs.map((doc) => doc.data() as GameAction);
    } catch (error) {
      logger.error('Error finding game actions by type', { type, error });
      throw error;
    }
  }

  /**
   * Finds actions by external ID
   * @param externalId External ID to search for
   * @returns Array of matching game actions
   */
  async findByExternalId(externalId: string): Promise<GameAction[]> {
    try {
      const snapshot = await this.db.collection(this.collectionPath).where('externalId', '==', externalId).get();

      return snapshot.docs.map((doc) => doc.data() as GameAction);
    } catch (error) {
      logger.error('Error finding game actions by external ID', { externalId, error });
      throw error;
    }
  }

  /**
   * Counts actions by status
   * @param status Status to count
   * @returns Count of actions with the specified status
   */
  async countByStatus(status: 'pending' | 'processed' | 'failed'): Promise<number> {
    try {
      const snapshot = await this.db.collection(this.collectionPath).where('status', '==', status).count().get();

      return snapshot.data().count;
    } catch (error) {
      logger.error('Error counting game actions by status', { status, error });
      throw error;
    }
  }
}

================
File: lib/progression/repositories/progression.repository.ts
================
import { BaseRepository, getCurrentTimeAsISO, logger } from '@codeheroes/common';
import { ActivityCounters, Collections } from '@codeheroes/types';
import { FieldValue, Firestore } from 'firebase-admin/firestore';
import { getXpProgress } from '../../config/level-thresholds';
import { getTimePeriodIds } from '../../utils/time-periods.utils';
import { ProgressionState, ProgressionUpdate, ProgressionUpdateResult } from '../core/progression-state.model';

/**
 * Interface representing a plan for transaction execution
 */
interface TransactionPlan {
  needsInitialization: boolean;
  userId?: string;
  update?: ProgressionUpdate;
  activity?: any;
  writes?: {
    stats: any;
    daily: any;
    weekly: any;
    activity: any;
  };
  result?: {
    state: ProgressionState;
    previousState: ProgressionState;
    leveledUp: boolean;
    newAchievements: string[];
  };
}

/**
 * Repository for managing user progression state in Firestore
 */
export class ProgressionRepository extends BaseRepository<ProgressionState> {
  protected collectionPath = Collections.Stats;

  constructor(db: Firestore) {
    super(db);
  }

  /**
   * Get user progression state
   */
  async getState(userId: string): Promise<ProgressionState | null> {
    logger.debug('Getting progression state', { userId });

    try {
      const statsDoc = await this.db
        .collection(Collections.Users)
        .doc(userId)
        .collection(Collections.Stats)
        .doc('current')
        .get();

      if (!statsDoc.exists) {
        logger.debug('No progression state found, returning null', { userId });
        return null;
      }

      const userStats = statsDoc.data()!;
      const { currentLevel, currentLevelXp, xpToNextLevel } = getXpProgress(userStats.xp || 0);

      return {
        userId,
        xp: userStats.xp || 0,
        level: currentLevel,
        currentLevelXp,
        xpToNextLevel,
        lastActivityDate: userStats.lastActivityDate || null,
        counters: userStats.counters || this.getInitialCounters(),
        countersLastUpdated: userStats.countersLastUpdated || getCurrentTimeAsISO(),
        achievements: userStats.achievements || [],
      };
    } catch (error) {
      logger.error('Error retrieving progression state', { userId, error });
      throw error;
    }
  }

  /**
   * Update user progression state
   */
  async updateState(userId: string, update: ProgressionUpdate, activity?: any): Promise<ProgressionUpdateResult> {
    logger.info('Updating progression state', { userId, xpGained: update.xpGained });

    // Get all the references we'll need
    const userRef = this.db.collection(Collections.Users).doc(userId);
    const statsRef = userRef.collection(Collections.Stats).doc('current');
    const timeFrames = getTimePeriodIds();
    const dailyStatsRef = userRef.collection('activityStats').doc('daily').collection('records').doc(timeFrames.daily);
    const weeklyStatsRef = userRef
      .collection('activityStats')
      .doc('weekly')
      .collection('records')
      .doc(timeFrames.weekly);

    // First get all data we need for planning
    try {
      const [statsDoc, dailyDoc, weeklyDoc] = await Promise.all([
        statsRef.get(),
        dailyStatsRef.get(),
        weeklyStatsRef.get(),
      ]);

      // If state doesn't exist, initialize it first
      if (!statsDoc.exists) {
        const initialState = await this.createInitialState(userId);
        return this.updateState(userId, update, activity);
      }

      // Create our transaction plan
      const plan = this.createTransactionPlan({
        userId,
        update,
        activity,
        statsDoc: statsDoc.data(),
        dailyDoc: dailyDoc.exists ? dailyDoc.data() : null,
        weeklyDoc: weeklyDoc.exists ? weeklyDoc.data() : null,
        timeFrames,
      });

      // Execute the transaction with this plan
      return this.executeStateUpdateTransaction(plan, {
        statsRef,
        dailyStatsRef,
        weeklyStatsRef,
        userRef,
      });
    } catch (error) {
      logger.error('Error updating progression state', { userId, error });
      throw error;
    }
  }

  /**
   * Create initial progression state for a new user
   */
  async createInitialState(userId: string): Promise<ProgressionState> {
    logger.debug('Creating initial progression state', { userId });

    const now = getCurrentTimeAsISO();
    const initialCounters = this.getInitialCounters();

    const initialState: ProgressionState = {
      userId,
      xp: 0,
      level: 1,
      currentLevelXp: 0,
      xpToNextLevel: 1000, // Default first level requirement
      lastActivityDate: null,
      counters: initialCounters,
      countersLastUpdated: now,
      achievements: [],
    };

    try {
      const userRef = this.db.collection(Collections.Users).doc(userId);
      const statsRef = userRef.collection(Collections.Stats).doc('current');

      await statsRef.set({
        ...initialState,
        createdAt: now,
        updatedAt: now,
      });

      logger.debug('Initial progression state created', { userId });
      return initialState;
    } catch (error) {
      logger.error('Error creating initial progression state', { userId, error });
      throw error;
    }
  }

  /**
   * Creates a transaction plan using pre-gathered data
   * This separates the business logic from the actual transaction execution
   */
  private createTransactionPlan({
    userId,
    update,
    activity,
    statsDoc,
    dailyDoc,
    weeklyDoc,
    timeFrames,
  }): TransactionPlan {
    // Handle missing state
    if (!statsDoc) {
      return {
        needsInitialization: true,
        userId,
        update,
        activity,
      };
    }

    // Calculate new state
    const currentState = statsDoc as ProgressionState;
    const previousState = { ...currentState };
    const newState = this.calculateNewState(currentState, update);

    // Determine if user leveled up
    const leveledUp = newState.level > previousState.level;

    // Prepare activity data for time-based stats
    const activityData = update.activityType
      ? {
          type: update.activityType,
          timestamp: getCurrentTimeAsISO(),
        }
      : undefined;

    // Prepare writes for each document
    const writes = {
      stats: {
        data: newState,
        merge: true,
      },
      daily: this.prepareTimeframeWrite(dailyDoc, timeFrames.daily, update, activityData),
      weekly: this.prepareTimeframeWrite(weeklyDoc, timeFrames.weekly, update, activityData),
      activity: activity
        ? {
            data: {
              ...activity,
              createdAt: activity.createdAt || getCurrentTimeAsISO(),
              updatedAt: getCurrentTimeAsISO(),
            },
          }
        : null,
    };

    return {
      needsInitialization: false,
      writes,
      result: {
        state: newState,
        previousState,
        leveledUp,
        newAchievements: update.achievements || [],
      },
    };
  }

  /**
   * Executes the transaction using the prepared plan
   */
  private async executeStateUpdateTransaction(
    plan: TransactionPlan,
    refs: {
      statsRef: FirebaseFirestore.DocumentReference;
      dailyStatsRef: FirebaseFirestore.DocumentReference;
      weeklyStatsRef: FirebaseFirestore.DocumentReference;
      userRef: FirebaseFirestore.DocumentReference;
    },
  ): Promise<ProgressionUpdateResult> {
    // If initialization is needed, handle specially
    if (plan.needsInitialization) {
      const initialState = await this.createInitialState(plan.userId!);
      return this.updateState(plan.userId!, plan.update!, plan.activity);
    }

    return this.executeTransaction(async (transaction) => {
      // Read all documents again to verify they haven't changed
      const freshStatsDoc = await transaction.get(refs.statsRef);

      // Apply stats update
      if (plan.writes?.stats) {
        transaction.set(refs.statsRef, plan.writes.stats.data, { merge: true });
      }

      // Apply daily stats update
      if (plan.writes?.daily) {
        if (!plan.writes.daily.exists) {
          transaction.set(refs.dailyStatsRef, plan.writes.daily.data);
        } else {
          transaction.update(refs.dailyStatsRef, plan.writes.daily.updates);
        }
      }

      // Apply weekly stats update
      if (plan.writes?.weekly) {
        if (!plan.writes.weekly.exists) {
          transaction.set(refs.weeklyStatsRef, plan.writes.weekly.data);
        } else {
          transaction.update(refs.weeklyStatsRef, plan.writes.weekly.updates);
        }
      }

      // Record activity if provided
      if (plan.writes?.activity && plan.activity) {
        const activityRef = refs.userRef
          .collection(Collections.Activities)
          .doc(plan.activity.id || `activity_${Date.now()}`);
        transaction.set(activityRef, plan.writes.activity.data);
      }

      return plan.result!;
    });
  }

  /**
   * Calculate the new state based on the current state and update
   */
  private calculateNewState(currentState: ProgressionState, update: ProgressionUpdate): ProgressionState {
    const newXp = currentState.xp + update.xpGained;
    const { currentLevel, currentLevelXp, xpToNextLevel } = getXpProgress(newXp);

    const newState = { ...currentState };
    newState.xp = newXp;
    newState.level = currentLevel;
    newState.currentLevelXp = currentLevelXp;
    newState.xpToNextLevel = xpToNextLevel;
    newState.lastActivityDate = new Date().toISOString().split('T')[0];
    newState.countersLastUpdated = getCurrentTimeAsISO();

    // Update counters
    if (update.activityType) {
      this.updateStateCounters(newState, update.activityType);
    }

    return newState;
  }

  /**
   * Update the counters in the state object based on activity type
   */
  private updateStateCounters(state: ProgressionState, activityType: string): void {
    if (!state.counters) {
      state.counters = this.getInitialCounters();
    }

    if (state.counters.actions[activityType] !== undefined) {
      state.counters.actions[activityType]++;
    }
  }

  /**
   * Prepare a write operation for a timeframe document (daily/weekly)
   */
  private prepareTimeframeWrite(doc: any, timeframeId: string, update: ProgressionUpdate, activityData?: any) {
    if (!doc) {
      // New document case
      return {
        exists: false,
        data: {
          timeframeId,
          xpGained: update.xpGained,
          counters: this.getInitialCounters(),
          countersLastUpdated: getCurrentTimeAsISO(),
          lastActivity: activityData,
        },
      };
    } else {
      // Update existing document case
      const updates: any = {
        xpGained: FieldValue.increment(update.xpGained),
        countersLastUpdated: getCurrentTimeAsISO(),
        lastActivity: activityData,
      };

      if (update.activityType) {
        updates[`counters.actions.${update.activityType}`] = FieldValue.increment(1);
      }

      return {
        exists: true,
        updates,
      };
    }
  }

  /**
   * Gets initial empty counters structure
   * @returns Empty counters object
   */
  private getInitialCounters(): ActivityCounters {
    return {
      actions: {
        code_push: 0,
        pull_request_create: 0,
        pull_request_merge: 0,
        pull_request_close: 0,
        code_review_submit: 0,
        code_review_comment: 0,
        issue_create: 0,
        issue_close: 0,
        issue_reopen: 0,
        workout_complete: 0,
        distance_milestone: 0,
        speed_record: 0,
      },
    };
  }
}

================
File: lib/progression/services/activity-recorder.service.ts
================
import { getCurrentTimeAsISO } from '@codeheroes/common';
import { Activity, GameAction, GameActionType, CodePushMetrics } from '@codeheroes/types';
import { ProgressionUpdate } from '../core/progression-state.model';
import { XpCalculationResult } from '../core/xp-calculation.model';

/**
 * Service responsible for creating activity records from game actions
 */
export class ActivityRecorderService {
  /**
   * Create an activity record from a game action
   * @param action The game action to create activity from
   * @param xpResult XP calculation result
   * @returns Activity record
   */
  createFromAction(action: GameAction, xpResult: XpCalculationResult): Activity {
    const now = getCurrentTimeAsISO();

    // Generate a unique ID
    const activityId = `act_${Date.now()}_${action.id}`;

    // Create the activity
    const activity: Activity = {
      id: activityId,
      userId: action.userId,
      type: 'game-action',
      sourceActionType: action.type,

      // Store context and metrics from the game action
      context: action.context,
      metrics: action.metrics,

      // Store XP information
      xp: {
        earned: xpResult.total,
        breakdown: xpResult.breakdown.map((item) => ({
          type: item.type,
          amount: item.amount,
          description: item.description,
        })),
      },

      // Add a user-facing description
      userFacingDescription: this.generateUserFacingDescription(action),

      // Store timestamps
      createdAt: now,
      updatedAt: now,

      // Include original event info
      eventId: action.externalId,
      provider: action.provider,

      // Add processing result
      processingResult: {
        processed: true,
        processedAt: now,
        xp: {
          awarded: xpResult.total,
          breakdown: xpResult.breakdown.map((item) => ({
            xp: item.amount,
            description: item.description,
          })),
          processed: true,
        },
      },
    };

    return activity;
  }

  /**
   * Create an activity record for a manual progression update
   * @param userId User ID
   * @param update Progression update data
   * @returns Activity record
   */
  createManualActivity(userId: string, update: ProgressionUpdate): Activity {
    const now = getCurrentTimeAsISO();

    // Generate a unique ID
    const activityId = `manual_${Date.now()}_${userId}`;

    // Create the manual activity
    const activity: Activity = {
      id: activityId,
      userId,
      type: 'game-action',
      sourceActionType: (update.activityType || 'manual_update') as GameActionType,

      // Create minimal context
      context: {
        type: 'manual',
        provider: 'system',
      },

      // No metrics for manual activities
      metrics: {
        type: 'manual',
        timestamp: now,
      },

      // Store XP information
      xp: {
        earned: update.xpGained,
        breakdown: [
          {
            type: 'manual',
            amount: update.xpGained,
            description: `Manual update: ${update.activityType || 'XP adjustment'}`,
          },
        ],
      },

      // Add a user-facing description
      userFacingDescription: `Manual ${update.activityType || 'XP'} update: +${update.xpGained}XP`,

      // Store timestamps
      createdAt: now,
      updatedAt: now,

      // Include event info
      eventId: activityId,
      provider: 'system',

      // Add processing result
      processingResult: {
        processed: true,
        processedAt: now,
        xp: {
          awarded: update.xpGained,
          breakdown: [
            {
              xp: update.xpGained,
              description: `Manual update: ${update.activityType || 'XP adjustment'}`,
            },
          ],
          processed: true,
        },
      },
    };

    return activity;
  }

  /**
   * Generate a user-friendly description for an activity
   * @param action Game action to describe
   * @returns User-facing description
   */
  private generateUserFacingDescription(action: GameAction): string {
    switch (action.type) {
      case 'code_push':
        return this.describeCodePush(action);
      case 'pull_request_create':
        return this.describePullRequestCreate(action);
      case 'pull_request_merge':
        return this.describePullRequestMerge(action);
      case 'pull_request_close':
        return this.describePullRequestClose(action);
      case 'code_review_submit':
        return this.describeCodeReview(action);
      default:
        return `${this.formatActionType(action.type)} activity`;
    }
  }

  /**
   * Create description for code push activity
   */
  private describeCodePush(action: GameAction): string {
    const metrics = action.metrics;
    const commitCount = metrics && metrics.type === 'code_push' ? (metrics as CodePushMetrics).commitCount : 1;

    const branchName = action.context.type === 'code_push' ? action.context.branch : 'unknown';
    const repoName = 'repository' in action.context ? action.context.repository.name : 'unknown';

    return commitCount === 1
      ? `Pushed a commit to ${branchName} in ${repoName}`
      : `Pushed ${commitCount} commits to ${branchName} in ${repoName}`;
  }

  /**
   * Create description for pull request creation
   */
  private describePullRequestCreate(action: GameAction): string {
    if (action.context.type !== 'pull_request') {
      return 'Created a pull request';
    }

    const prTitle = action.context.pullRequest.title;
    const prNumber = action.context.pullRequest.number;
    const repoName = action.context.repository.name;

    return `Created pull request #${prNumber}: "${prTitle}" in ${repoName}`;
  }

  /**
   * Create description for pull request merge
   */
  private describePullRequestMerge(action: GameAction): string {
    if (action.context.type !== 'pull_request') {
      return 'Merged a pull request';
    }

    const prTitle = action.context.pullRequest.title;
    const prNumber = action.context.pullRequest.number;
    const repoName = action.context.repository.name;

    return `Merged pull request #${prNumber}: "${prTitle}" in ${repoName}`;
  }

  /**
   * Create description for pull request closure
   */
  private describePullRequestClose(action: GameAction): string {
    if (action.context.type !== 'pull_request') {
      return 'Closed a pull request';
    }

    const prTitle = action.context.pullRequest.title;
    const prNumber = action.context.pullRequest.number;
    const repoName = action.context.repository.name;

    return `Closed pull request #${prNumber}: "${prTitle}" in ${repoName}`;
  }

  /**
   * Create description for code review submission
   */
  private describeCodeReview(action: GameAction): string {
    if (action.context.type !== 'code_review') {
      return 'Submitted a code review';
    }

    const prNumber = action.context.pullRequest.number;
    const repoName = action.context.repository.name;
    const state = action.context.review.state;

    if (state === 'approved') {
      return `Approved pull request #${prNumber} in ${repoName}`;
    } else if (state === 'changes_requested') {
      return `Requested changes on pull request #${prNumber} in ${repoName}`;
    } else {
      return `Commented on pull request #${prNumber} in ${repoName}`;
    }
  }

  /**
   * Format action type for display
   */
  private formatActionType(actionType: string): string {
    return actionType
      .replace(/_/g, ' ')
      .split(' ')
      .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ');
  }
}

================
File: lib/progression/services/milestone-reward.service.ts
================
import { logger } from '@codeheroes/common';
import { GameAction, ProgressionState } from '@codeheroes/types';
import { LevelService } from '../../rewards/services/level.service';
import { RewardService } from '../../rewards/services/reward.service';

/**
 * Service focused on detecting and granting milestone rewards
 */
export class MilestoneRewardService {
  private levelService: LevelService;
  private rewardService: RewardService;

  constructor() {
    this.levelService = new LevelService();
    this.rewardService = new RewardService();
  }

  /**
   * Check if a user's current state has reached any milestone that should trigger rewards
   */
  async checkAndGrantMilestoneRewards(
    userId: string,
    state: ProgressionState,
    previousState?: Partial<ProgressionState>,
    action?: GameAction,
  ): Promise<boolean> {
    let rewardsGranted = false;

    // Check for level-up milestone
    if (previousState && state.level > (previousState.level || 0)) {
      logger.info('Level-up milestone detected', {
        userId,
        previousLevel: previousState.level,
        newLevel: state.level,
      });

      await this.handleLevelUpRewards(userId, state.level);
      rewardsGranted = true;
    }

    // Check for activity count milestones
    if (action) {
      const actionMilestone = this.checkActivityMilestone(action, state);
      if (actionMilestone) {
        logger.info('Activity milestone detected', {
          userId,
          actionType: action.type,
          milestone: actionMilestone,
        });

        await this.handleActivityMilestone(userId, action.type, actionMilestone);
        rewardsGranted = true;
      }
    }

    return rewardsGranted;
  }

  /**
   * Check if the action has reached a milestone based on its count
   */
  private checkActivityMilestone(action: GameAction, state: ProgressionState): number | null {
    const activityCount = state.counters?.actions?.[action.type] || 0;
    const milestones = [10, 50, 100, 500];

    const milestone = milestones.find((m) => activityCount === m);
    return milestone || null;
  }

  /**
   * Handle rewards for reaching an activity count milestone
   */
  private async handleActivityMilestone(userId: string, actionType: string, milestone: number): Promise<void> {
    // Generate a unique ID for the reward
    const rewardId = `${actionType}_milestone_${milestone}_${Date.now()}`;

    await this.rewardService.grantReward(userId, {
      id: rewardId,
      type: 'BADGE',
      name: `${actionType.replace(/_/g, ' ')} Expert`,
      description: `Completed ${milestone} ${actionType.replace(/_/g, ' ')} actions`,
    });

    logger.info('Activity milestone reward granted', { userId, actionType, milestone });
  }

  /**
   * Handle rewards for level-up milestones
   */
  private async handleLevelUpRewards(userId: string, newLevel: number): Promise<void> {
    const previousLevel = newLevel - 1;
    const levelRequirements = this.levelService.getNextLevelRequirements(previousLevel);

    if (levelRequirements.rewards && levelRequirements.rewards.length > 0) {
      logger.info('Granting level-up rewards', {
        userId,
        newLevel,
        rewardCount: levelRequirements.rewards.length,
      });

      for (const reward of levelRequirements.rewards) {
        const rewardId = `level_${newLevel}_reward_${reward.id}_${Date.now()}`;

        await this.rewardService.grantReward(userId, {
          id: rewardId,
          type: reward.type,
          name: reward.name,
          amount: reward.amount,
        });
      }
    }
  }
}

================
File: lib/progression/services/progression.service.ts
================
import { logger } from '@codeheroes/common';
import { GameAction, ActionResult, Activity } from '@codeheroes/types';

import { ProgressionRepository } from '../repositories/progression.repository';
import { ActivityRepository } from '../repositories/activity.repository';
import { GameActionRepository } from '../repositories/game-action.repository';
import { XpCalculatorService } from './xp-calculator.service';
import { ActivityRecorderService } from './activity-recorder.service';
import { EventPublisherService } from '../events/event-publisher.service';
import { ProgressionUpdate } from '../core/progression-state.model';

/**
 * Main service for managing user progression
 * Acts as a facade to coordinate between specialized services
 */
export class ProgressionService {
  constructor(
    private stateRepository: ProgressionRepository,
    private activityRepository: ActivityRepository,
    private gameActionRepository: GameActionRepository,
    private xpCalculator: XpCalculatorService,
    private activityRecorder: ActivityRecorderService,
    private eventPublisher: EventPublisherService,
  ) {}

  /**
   * Process a game action and update user progression
   * @param action The game action to process
   * @returns Result of the action processing
   */
  async processGameAction(action: GameAction): Promise<ActionResult> {
    logger.info(`Processing game action: ${action.type} for user: ${action.userId}`);

    try {
      // 1. Get or create user's progression state
      let state = await this.stateRepository.getState(action.userId);
      if (!state) {
        state = await this.stateRepository.createInitialState(action.userId);
      }

      // 2. Calculate XP for the action
      const xpResult = await this.xpCalculator.calculateForAction(action);
      logger.info('XP calculation result', {
        userId: action.userId,
        actionType: action.type,
        xpGained: xpResult.total,
        breakdown: xpResult.breakdown,
      });

      // 3. Create activity record
      const activity = this.activityRecorder.createFromAction(action, xpResult);

      // 4. Record the activity in the database
      const recordedActivity = await this.activityRepository.recordActivity(activity);

      // 5. Update user's progression state
      const progressionUpdate: ProgressionUpdate = {
        xpGained: xpResult.total,
        activityType: action.type,
      };

      const updateResult = await this.stateRepository.updateState(action.userId, progressionUpdate, recordedActivity);

      // 6. Publish events based on state changes
      await this.publishProgressionEvents(action.userId, updateResult, recordedActivity);

      // 7. Mark the game action as processed
      await this.gameActionRepository.markAsProcessed(action.id);

      // 8. Return the action result
      return {
        xpGained: xpResult.total,
        level: updateResult.state.level,
        currentLevelProgress: {
          level: updateResult.state.level,
          currentLevelXp: updateResult.state.currentLevelXp,
          xpToNextLevel: updateResult.state.xpToNextLevel,
        },
        leveledUp: updateResult.leveledUp,
      };
    } catch (error) {
      logger.error('Error processing game action', {
        actionId: action.id,
        error: error instanceof Error ? error.message : String(error),
      });

      // Mark action as failed with error details
      await this.gameActionRepository.markAsFailed(action.id, error instanceof Error ? error.message : 'Unknown error');

      throw error;
    }
  }

  /**
   * Update a user's progression directly (not from a game action)
   * @param userId User ID to update
   * @param update The progression update to apply
   * @returns Updated progression state
   */
  async updateProgression(userId: string, update: ProgressionUpdate): Promise<ActionResult> {
    logger.info(`Updating progression for user: ${userId}`, { xpGained: update.xpGained });

    try {
      // 1. Get or create user's progression state
      let state = await this.stateRepository.getState(userId);
      if (!state) {
        state = await this.stateRepository.createInitialState(userId);
      }

      // 2. Create manual activity if needed
      let activity: Activity | undefined;
      if (update.activityType) {
        activity = this.activityRecorder.createManualActivity(userId, update);
        await this.activityRepository.recordActivity(activity);
      }

      // 3. Update progression state
      const updateResult = await this.stateRepository.updateState(userId, update, activity);

      // 4. Publish events
      if (activity) {
        await this.publishProgressionEvents(userId, updateResult, activity);
      }

      // 5. Return result
      return {
        xpGained: update.xpGained,
        level: updateResult.state.level,
        currentLevelProgress: {
          level: updateResult.state.level,
          currentLevelXp: updateResult.state.currentLevelXp,
          xpToNextLevel: updateResult.state.xpToNextLevel,
        },
        leveledUp: updateResult.leveledUp,
      };
    } catch (error) {
      logger.error('Error updating progression', {
        userId,
        error: error instanceof Error ? error.message : String(error),
      });
      throw error;
    }
  }

  /**
   * Get a user's current progression state
   * @param userId User ID to get state for
   * @returns The current progression state
   */
  async getProgressionState(userId: string) {
    return this.stateRepository.getState(userId);
  }

  /**
   * Get recent activities for a user
   * @param userId User ID to get activities for
   * @param limit Maximum number of activities to return
   * @returns Array of recent activities
   */
  async getRecentActivities(userId: string, limit = 10) {
    return this.activityRepository.getRecentActivities(userId, limit);
  }

  /**
   * Publish events based on progression state changes
   * @param userId User ID
   * @param updateResult Result of the state update
   * @param activity The activity that caused the update
   */
  private async publishProgressionEvents(userId: string, updateResult: any, activity: Activity) {
    // 1. Always publish activity recorded event
    await this.eventPublisher.emitActivityRecorded(userId, activity);

    // 2. Publish XP gained event
    await this.eventPublisher.emitXpGained(userId, activity, updateResult.state, updateResult.previousState);

    // 3. Publish level up event if user leveled up
    if (updateResult.leveledUp) {
      await this.eventPublisher.emitLevelUp(userId, updateResult.state, updateResult.previousState);

      logger.info('User leveled up', {
        userId,
        newLevel: updateResult.state.level,
        previousLevel: updateResult.previousState.level,
      });
    }

    // 4. Publish achievement events if there are new achievements
    if (updateResult.newAchievements && updateResult.newAchievements.length > 0) {
      for (const achievementId of updateResult.newAchievements) {
        await this.eventPublisher.emitAchievementUnlocked(userId, achievementId);
      }
    }
  }
}

================
File: lib/progression/services/xp-calculator.service.ts
================
import { logger } from '@codeheroes/common';
import { GameAction, GameActionType } from '@codeheroes/types';
import { XP_VALUES } from '../../config/xp-values.config';
import { XpCalculationResult, XpBreakdownItem } from '../core/xp-calculation.model';
import { ActionHandlerFactory } from '../handlers/action-handler.factory';

/**
 * Service responsible for calculating XP based on game actions
 */
export class XpCalculatorService {
  /**
   * Calculate XP for a given game action
   * @param action The game action to calculate XP for
   * @returns XP calculation result with breakdown
   */
  async calculateForAction(action: GameAction): Promise<XpCalculationResult> {
    logger.debug(`Calculating XP for action: ${action.type}`);

    try {
      // Get appropriate handler for this action type
      const handler = ActionHandlerFactory.getHandler(action.type);

      // Calculate base XP for this action type
      const baseXp = this.getBaseXpForActionType(action.type);

      // Calculate bonuses using the specific handler
      const bonuses = handler.calculateBonuses(action.context, action.metrics);

      // Calculate total XP
      const totalXp = baseXp + bonuses.totalBonus;

      // Create XP breakdown
      const breakdown: XpBreakdownItem[] = [
        {
          type: 'base',
          amount: baseXp,
          description: `Base XP for ${this.formatActionType(action.type)}`,
        },
      ];

      // Add bonus breakdowns
      for (const [bonusType, amount] of Object.entries(bonuses.breakdown)) {
        if (amount > 0) {
          breakdown.push({
            type: bonusType,
            amount,
            description: this.getBonusDescription(bonusType, action.type),
          });
        }
      }

      // Create final result
      const result: XpCalculationResult = {
        baseXp,
        bonusXp: bonuses.totalBonus,
        total: totalXp,
        breakdown,
      };

      logger.debug('XP calculation complete', {
        actionType: action.type,
        total: result.total,
        breakdown: result.breakdown.map((b) => `${b.type}: ${b.amount}`),
      });

      return result;
    } catch (error) {
      logger.error('Error calculating XP', {
        actionType: action.type,
        error: error instanceof Error ? error.message : String(error),
      });
      throw error;
    }
  }

  /**
   * Calculate XP for a manual update (not from a game action)
   * @param activityType Type of activity
   * @param amount Optional custom XP amount
   * @returns XP calculation result
   */
  calculateForManualUpdate(activityType: string, amount?: number): XpCalculationResult {
    // For manual updates, we use either the specified amount or a default
    const xpAmount = amount || this.getDefaultManualXp(activityType);

    return {
      baseXp: xpAmount,
      bonusXp: 0,
      total: xpAmount,
      breakdown: [
        {
          type: 'manual',
          amount: xpAmount,
          description: `Manual ${activityType} update`,
        },
      ],
    };
  }

  /**
   * Get base XP value for a given action type
   * @param actionType Game action type
   * @returns Base XP value
   */
  private getBaseXpForActionType(actionType: GameActionType): number {
    switch (actionType) {
      case 'code_push':
        return XP_VALUES.CODE_PUSH.BASE;
      case 'pull_request_create':
        return XP_VALUES.PULL_REQUEST.CREATE.BASE;
      case 'pull_request_merge':
        return XP_VALUES.PULL_REQUEST.MERGE.BASE;
      case 'pull_request_close':
        return XP_VALUES.PULL_REQUEST.CLOSE.BASE;
      case 'code_review_submit':
        return XP_VALUES.CODE_REVIEW.BASE;
      default:
        // Default value for other action types
        return 50;
    }
  }

  /**
   * Get default XP value for manual updates
   * @param activityType Activity type string
   * @returns Default XP amount
   */
  private getDefaultManualXp(activityType: string): number {
    // Map activity types to default XP values
    const defaultValues: Record<string, number> = {
      user_registration: 100,
      profile_completion: 150,
      admin_award: 200,
      challenge_completion: 250,
      daily_login: 25,
    };

    return defaultValues[activityType] || 50;
  }

  /**
   * Format action type for user-friendly display
   * @param actionType Game action type
   * @returns Formatted action type string
   */
  private formatActionType(actionType: GameActionType): string {
    return actionType
      .replace(/_/g, ' ')
      .split(' ')
      .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ');
  }

  /**
   * Get user-friendly description for bonus types
   * @param bonusType Type of bonus
   * @param actionType Related game action type
   * @returns User-friendly description
   */
  private getBonusDescription(bonusType: string, actionType: GameActionType): string {
    const bonusDescriptions: Record<string, string> = {
      multipleCommits: 'Bonus for multiple commits',
      multipleFiles: 'Bonus for changes across multiple files',
      significantChanges: 'Bonus for significant code changes',
      detailedReview: 'Bonus for detailed review comments',
      thoroughReview: 'Bonus for thorough review with suggestions',
      streak: 'Bonus for activity streak',
      firstDaily: 'First activity of the day',
    };

    return bonusDescriptions[bonusType] || `${bonusType} bonus`;
  }
}

================
File: lib/progression/utils/level.utils.ts
================
import { LevelDefinition } from '../../config/level-definitions.config';
import { getLevelRequirements, getXpProgress } from '../../config/level-thresholds';

export function calculateXpToNextLevel(totalXp: number): number {
  const { xpToNextLevel } = getXpProgress(totalXp);
  return xpToNextLevel;
}

export function calculateLevelProgress(totalXp: number): number {
  const { currentLevelXp, xpToNextLevel } = getXpProgress(totalXp);
  return xpToNextLevel > 0 ? Math.min(100, (currentLevelXp / xpToNextLevel) * 100) : 100;
}

export function getLevelRewards(level: number): LevelDefinition['rewards'] | undefined {
  const config = getLevelRequirements(level);
  return config?.rewards;
}

================
File: lib/rewards/services/badge.service.ts
================
import { DatabaseInstance } from '@codeheroes/common';
import { Collections } from '@codeheroes/types';
import { FieldValue, Firestore } from 'firebase-admin/firestore';
import { EventProcessorService } from '../../progression/events/event-processor.service';

export interface Badge {
  id: string;
  name: string;
  description?: string;
  earnedAt?: string;
  xp?: number;
}

interface BadgeContext {
  totalActions: number;
  actionType: string;
  metadata?: Record<string, any>;
}

export class BadgeService {
  private db: Firestore;
  private eventHandler: EventProcessorService;

  constructor(eventHandler?: EventProcessorService) {
    this.db = DatabaseInstance.getInstance();
    this.eventHandler = eventHandler || new EventProcessorService();
  }

  async processBadges(userId: string, context: BadgeContext): Promise<Badge[]> {
    const userRef = this.db.collection(Collections.Users).doc(userId);
    const badgesRef = userRef.collection(Collections.Badges);
    const badgeSnapshot = await badgesRef.get();
    const existingBadges = new Set(badgeSnapshot.docs.map((doc) => doc.id));
    const earnedBadges: Badge[] = [];

    // Check activity-based badges
    const activityBadges = await this.checkActivityBadges(context.actionType, context.totalActions, existingBadges);
    earnedBadges.push(...activityBadges);

    // Save earned badges
    for (const badge of earnedBadges) {
      await badgesRef.doc(badge.id).set({
        ...badge,
        earnedAt: new Date().toISOString(),
      });

      // Update user stats to reflect new badge
      await userRef
        .collection(Collections.Stats)
        .doc('current')
        .update({
          'stats.badges.total': FieldValue.increment(1),
          'stats.badges.lastEarned': badge.earnedAt,
        });
    }

    return earnedBadges;
  }

  async getUserBadges(userId: string): Promise<Badge[]> {
    const snapshot = await this.db.collection(Collections.Users).doc(userId).collection(Collections.Badges).get();

    return snapshot.docs.map(
      (doc) =>
        ({
          ...doc.data(),
          id: doc.id,
        }) as Badge,
    );
  }

  private async checkActivityBadges(
    actionType: string,
    totalActions: number,
    existingBadges: Set<string>,
  ): Promise<Badge[]> {
    const activityBadges: Badge[] = [];
    const milestones = [
      { id: 'first_action', name: 'First Steps', threshold: 1, xp: 100 },
      { id: 'ten_actions', name: 'Getting Started', threshold: 10, xp: 500 },
      { id: 'fifty_actions', name: 'Regular Contributor', threshold: 50, xp: 2000 },
      { id: 'hundred_actions', name: 'Dedicated Developer', threshold: 100, xp: 5000 },
    ];

    for (const milestone of milestones) {
      if (totalActions >= milestone.threshold && !existingBadges.has(milestone.id)) {
        activityBadges.push({
          id: milestone.id,
          name: milestone.name,
          description: `Complete ${milestone.threshold} ${actionType} actions`,
          xp: milestone.xp,
        });
      }
    }

    return activityBadges;
  }
}

================
File: lib/rewards/services/level.service.ts
================
import { LevelRequirementItem, LevelReward, RewardType } from '@codeheroes/types';
import { getLevelRequirements, getNextLevelRequirements, getXpProgress } from '../../config/level-thresholds';

export class LevelService {
  calculateLevelProgress(totalXp: number) {
    const { currentLevel, currentLevelXp, xpToNextLevel } = getXpProgress(totalXp);
    const currentLevelConfig = getLevelRequirements(currentLevel);
    const nextLevelConfig = getNextLevelRequirements(currentLevel);

    return {
      level: currentLevel,
      progress: xpToNextLevel > 0 ? Math.floor((currentLevelXp / xpToNextLevel) * 100) : 100,
      currentLevelXp,
      xpToNextLevel,
      totalXp,
      rewards: this.mapConfigRewardsToLevelRewards(currentLevelConfig?.rewards),
      requirements: [], // We'll leave this empty for now as it's not critical
    };
  }

  getNextLevelRequirements(level: number): {
    xpNeeded: number;
    requirements: LevelRequirementItem[];
    rewards: LevelReward[];
  } {
    const nextLevel = getNextLevelRequirements(level);
    if (!nextLevel) {
      return {
        xpNeeded: 0,
        requirements: [],
        rewards: [],
      };
    }

    const currentLevel = getLevelRequirements(level);
    return {
      xpNeeded: nextLevel.xpRequired - (currentLevel?.xpRequired || 0),
      requirements: [], // We'll implement requirements later if needed
      rewards: this.mapConfigRewardsToLevelRewards(nextLevel.rewards),
    };
  }

  private mapConfigRewardsToLevelRewards(configRewards?: {
    title?: string;
    badges?: string[];
    unlocks?: string[];
  }): LevelReward[] {
    const rewards: LevelReward[] = [];

    if (!configRewards) {
      return rewards;
    }

    if (configRewards.title) {
      rewards.push({
        type: 'POINTS' as RewardType,
        id: `title_${configRewards.title.toLowerCase().replace(/\s+/g, '_')}`,
        name: configRewards.title,
      });
    }

    if (configRewards.badges) {
      configRewards.badges.forEach((badge) => {
        rewards.push({
          type: 'BADGE' as RewardType,
          id: badge,
          name: badge,
        });
      });
    }

    if (configRewards.unlocks) {
      configRewards.unlocks.forEach((unlock) => {
        rewards.push({
          type: 'FEATURE_UNLOCK' as RewardType,
          id: unlock,
          name: unlock,
        });
      });
    }

    return rewards;
  }
}

================
File: lib/rewards/services/reward.service.ts
================
import { DatabaseInstance } from '@codeheroes/common';
import { NotificationService } from '@codeheroes/notifications';
import { Collections, RewardType } from '@codeheroes/types';
import { FieldValue, Firestore } from 'firebase-admin/firestore';
import { EventPublisherService } from '../../progression/events/event-publisher.service';
import { BadgeService } from './badge.service';

export interface Reward {
  id: string;
  type: RewardType;
  name: string;
  description?: string;
  amount?: number;
  metadata?: Record<string, any>;
  earnedAt?: string;
}

export interface RewardClaim {
  rewardId: string;
  userId: string;
  claimedAt: string;
  expiresAt?: string;
}

export class RewardService {
  private db: Firestore;
  private notificationService: NotificationService;
  private badgeService: BadgeService;
  private eventService: EventPublisherService;

  constructor(badgeService?: BadgeService) {
    this.db = DatabaseInstance.getInstance();
    this.notificationService = new NotificationService();
    this.badgeService = badgeService || new BadgeService();
    this.eventService = new EventPublisherService();
  }

  async grantReward(userId: string, reward: Reward): Promise<void> {
    const userRef = this.db.collection(Collections.Users).doc(userId);
    const rewardRef = userRef.collection(Collections.Rewards).doc(reward.id);

    await this.db.runTransaction(async (transaction) => {
      const doc = await transaction.get(rewardRef);
      if (doc.exists) {
        return; // Reward already granted
      }

      const rewardData = {
        ...reward,
        earnedAt: new Date().toISOString(),
        claimed: false,
      };

      transaction.set(rewardRef, rewardData);

      // Create notification
      await this.notificationService.createNotification(userId, {
        type: 'REWARD_EARNED',
        title: 'New Reward!',
        message: `You've earned: ${reward.name}`,
        metadata: { rewardId: reward.id, rewardType: reward.type },
      });

      // Update user stats to reflect new reward
      transaction.update(userRef.collection(Collections.Stats).doc('current'), {
        'stats.rewards.total': FieldValue.increment(1),
        'stats.rewards.lastEarned': rewardData.earnedAt,
      });

      // Handle specific reward types
      switch (reward.type) {
        case 'BADGE':
          await this.badgeService.processBadges(userId, {
            actionType: 'reward_badge',
            totalActions: 1,
          });
          break;
        case 'POINTS':
          if (reward.amount) {
            transaction.update(userRef.collection(Collections.Stats).doc('current'), {
              xp: FieldValue.increment(reward.amount),
            });
          }
          break;
      }
    });
  }

  async claimReward(userId: string, rewardId: string): Promise<boolean> {
    const userRef = this.db.collection(Collections.Users).doc(userId);
    const rewardRef = userRef.collection(Collections.Rewards).doc(rewardId);
    let success = false;

    await this.db.runTransaction(async (transaction) => {
      const doc = await transaction.get(rewardRef);
      if (!doc.exists || doc.data()?.claimed) {
        return false;
      }

      const claim: RewardClaim = {
        rewardId,
        userId,
        claimedAt: new Date().toISOString(),
      };

      transaction.update(rewardRef, {
        claimed: true,
        claimedAt: claim.claimedAt,
      });

      // Update user stats
      transaction.update(userRef.collection(Collections.Stats).doc('current'), {
        'stats.rewards.claimed': FieldValue.increment(1),
        'stats.rewards.lastClaimed': claim.claimedAt,
      });

      success = true;
      return true;
    });

    if (success) {
      await this.notificationService.createNotification(userId, {
        type: 'REWARD_CLAIMED',
        title: 'Reward Claimed!',
        message: "You've successfully claimed your reward",
        metadata: { rewardId },
      });
    }

    return success;
  }

  async getUnclaimedRewards(userId: string): Promise<Reward[]> {
    const snapshot = await this.db
      .collection(Collections.Users)
      .doc(userId)
      .collection(Collections.Rewards)
      .where('claimed', '==', false)
      .get();

    return snapshot.docs.map(
      (doc) =>
        ({
          ...doc.data(),
          id: doc.id,
        }) as Reward,
    );
  }

  async getRewardHistory(userId: string, limit = 50): Promise<Reward[]> {
    const snapshot = await this.db
      .collection(Collections.Users)
      .doc(userId)
      .collection(Collections.Rewards)
      .orderBy('earnedAt', 'desc')
      .limit(limit)
      .get();

    return snapshot.docs.map(
      (doc) =>
        ({
          ...doc.data(),
          id: doc.id,
        }) as Reward,
    );
  }
}

================
File: lib/utils/time-periods.utils.ts
================
import { getCurrentTimeAsISO } from '@codeheroes/common';

export interface TimePeriod {
  daily: string;
  weekly: string;
}

/**
 * Get daily (YYYY-MM-DD) and weekly (YYYY-WXX) IDs for a given timestamp
 */
export function getTimePeriodIds(timestamp?: string): TimePeriod {
  const date = timestamp ? new Date(timestamp) : new Date();

  // Daily ID: YYYY-MM-DD
  const dailyId = date.toISOString().slice(0, 10);

  // Weekly ID: YYYY-WXX
  const weekNumber = getISOWeekNumber(date);
  const weeklyId = `${date.getFullYear()}-W${weekNumber.toString().padStart(2, '0')}`;

  return { daily: dailyId, weekly: weeklyId };
}

/**
 * Calculate ISO week number for consistent weekly grouping
 */
export function getISOWeekNumber(date: Date): number {
  const d = new Date(date);
  d.setHours(0, 0, 0, 0);
  d.setDate(d.getDate() + 4 - (d.getDay() || 7)); // Set to nearest Thursday
  const yearStart = new Date(d.getFullYear(), 0, 1);
  return Math.ceil(((d.getTime() - yearStart.getTime()) / 86400000 + 1) / 7);
}

/**
 * Get the ISO week and year for a given date
 */
export function getISOWeekYear(date: Date): { year: number; week: number } {
  const d = new Date(date);
  d.setHours(0, 0, 0, 0);
  d.setDate(d.getDate() + 4 - (d.getDay() || 7));
  const yearStart = new Date(d.getFullYear(), 0, 1);
  const weekNum = Math.ceil(((d.getTime() - yearStart.getTime()) / 86400000 + 1) / 7);

  return {
    year: d.getFullYear(),
    week: weekNum,
  };
}

/**
 * Generate an array of daily IDs for a given number of past days
 */
export function getRecentDailyIds(days: number): string[] {
  const dailyIds: string[] = [];
  const now = new Date();

  for (let i = 0; i < days; i++) {
    const date = new Date(now);
    date.setDate(date.getDate() - i);
    dailyIds.push(date.toISOString().slice(0, 10));
  }

  return dailyIds;
}

/**
 * Generate an array of weekly IDs for a given number of past weeks
 */
export function getRecentWeeklyIds(weeks: number): string[] {
  const weeklyIds: string[] = [];
  const now = new Date();

  for (let i = 0; i < weeks; i++) {
    const date = new Date(now);
    date.setDate(date.getDate() - i * 7);
    const { year, week } = getISOWeekYear(date);
    weeklyIds.push(`${year}-W${week.toString().padStart(2, '0')}`);
  }

  return weeklyIds;
}

/**
 * Gets a consistent timestamp in UTC for the start of a day
 */
export function getDayStartTimestamp(date: Date): string {
  const d = new Date(date);
  d.setUTCHours(0, 0, 0, 0);
  return d.toISOString();
}

/**
 * Gets a consistent timestamp in UTC for the end of a day
 */
export function getDayEndTimestamp(date: Date): string {
  const d = new Date(date);
  d.setUTCHours(23, 59, 59, 999);
  return d.toISOString();
}

================
File: index.ts
================
// // Unified Services
// export * from './lib/events/event-processor.service';
// export * from './lib/events/event-publisher.service';
// export * from './lib/progression/services/user-progression.service';
// export * from './lib/activities/services/activity.service';

// // Supporting Services
// export * from './lib/rewards/services/badge.service';
// export * from './lib/rewards/services/level.service';
// export * from './lib/rewards/services/reward.service';

// // Constants
// export * from './lib/config/xp-values.config';
// export * from './lib/config/level-thresholds';
// export * from './lib/config/level-definitions.config';

// // Utilities
// export * from './lib/utils/time-periods.utils';

// // Factories
// export * from './lib/factories/action-handler.factory';

// // Repositories > new refactoring
// export * from './lib/progression/core/service-registry';

// File: libs/server/progression-engine/src/index.ts

// Core models
export * from './lib/progression/core/progression-state.model';
export * from './lib/progression/core/progression-events.model';
export * from './lib/progression/core/xp-calculation.model';
export * from './lib/progression/core/service-registry';

// Repositories
export * from './lib/progression/repositories/progression.repository';
export * from './lib/progression/repositories/activity.repository';
export * from './lib/progression/repositories/game-action.repository';

// Services
export * from './lib/progression/services/progression.service';
export * from './lib/progression/services/xp-calculator.service';
export * from './lib/progression/services/activity-recorder.service';

// Handlers
export * from './lib/progression/handlers/action-handler.base';
export * from './lib/progression/handlers/action-handler.factory';

// Commands
export * from './lib/progression/commands/process-game-action.command';
export * from './lib/progression/commands/update-progression.command';
export * from './lib/progression/commands/command-factory';

// Events
export * from './lib/progression/events/event-processor.service';
export * from './lib/progression/events/event-publisher.service';

// Supporting Services (existing)
export * from './lib/rewards/services/badge.service';
export * from './lib/rewards/services/level.service';
export * from './lib/rewards/services/reward.service';

// Constants
export * from './lib/config/xp-values.config';
export * from './lib/config/level-thresholds';
export * from './lib/config/level-definitions.config';

// Utilities
export * from './lib/utils/time-periods.utils';



================================================================
End of Codebase
================================================================
